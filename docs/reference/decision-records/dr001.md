# DR-001: Use Mono-Repository Layout (Single-Repository Type)

## Status

- [x] Accepted
- [ ] Proposed
- [ ] Rejected
- [ ] Deprecated
- [ ] Superseded

**Date**: 2025-11-03

---

## Context

The platform consists of multiple related components:

- CLI tools, VSCode extension, MCP servers
- Documentation, automation scripts, contracts
- Feature specifications

Requirements:

1. Coordinated development across components
2. Simplified dependency management
3. Atomic commits across multiple components
4. Code sharing and refactoring support
5. Clear module boundaries
6. Independent module versioning

**Problem**: How to organize the codebase to balance maintainability, development velocity, and deployment flexibility?

---

## Decision

Use **mono-repository layout** with all components in one repository with clear module boundaries.

### Structure

```text
cli/
├── src/                          # Source code
│   └── mcp/                      # MCP servers
├── .vscode/extensions/           # VSCode extension
├── automation/                   # Automation scripts
├── docs/                         # Documentation (Diataxis)
├── contracts/                    # Deployable units
└── specs/                        # Feature specifications
```

### Module Detection

Identified by:

- `go.mod` (Go), `package.json` (Node.js), `pyproject.toml` (Python)
- Conventional directories: `docs/`, `automation/`, `contracts/`

### Versioning

Each module versioned independently using semantic versioning, tracked in commit messages with module prefixes.

---

## Consequences

### Positive

- **Coordinated development**: Atomic commits, single-PR refactoring, consistent versioning
- **Simplified dependencies**: No publishing internal packages, direct imports, single update workflow
- **Code sharing**: Easy to share utilities, consistent patterns, simplified refactoring
- **Unified tooling**: Single CI/CD pipeline, consistent commands, shared automation
- **Developer experience**: Single clone, searchable codebase, simplified onboarding

### Negative

- **Repository size**: Larger clone, more files to index, longer CI runs
- **Build complexity**: Need module detection, smart build system to avoid rebuilding unchanged modules
- **Access control**: Cannot restrict per-module access via repository permissions
- **Merge conflicts**: Higher potential with multiple teams, requires coordination

---

## Alternatives Considered

### 1. Multi-Repository (Poly-Repo)

Separate repository for each component.

**Why Not Chosen**: Tight coupling between components makes cross-repo coordination too costly. Complex dependency management, difficult atomic changes, version coordination complexity.

### 2. Mono-Repository with Git Submodules

Main repository with submodules for each component.

**Why Not Chosen**: Submodules add complexity (sync issues, difficult atomic commits) without enough benefits over true mono-repository.

### 3. Mono-Repository with Workspaces Only

Use npm/yarn/Go workspaces without additional module detection.

**Why Not Chosen**: Limited to one language ecosystem. Codebase is multi-language (Go, TypeScript, Python, Bash).

---

## Implementation

### Commit Convention

```text
# Single module
module: type: description

# Multiple modules
multi-module: type: description
```

### Build Optimization

- Detect changed modules via git diff
- Only build/test affected modules
- Cache unchanged module artifacts

---

## Related Decisions

- [DR-002: Versioning and Trunk-Based Development](dr002.md)
