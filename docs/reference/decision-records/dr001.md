# DR-001: Use Mono-Repository Layout (Single-Repository Type)

## Status

- [x] Accepted
- [ ] Proposed
- [ ] Rejected
- [ ] Deprecated
- [ ] Superseded

**Date**: 2025-11-03

---

## Context

The Simply CLI platform consists of multiple related components that need to work together:

- **CLI tools** - Command-line interface for project operations
- **VSCode extension** - IDE integration with MCP servers
- **MCP servers** - Multiple specialized servers (vscode, pwsh, docs, github)
- **Documentation** - Comprehensive docs following Diataxis framework
- **Automation scripts** - Build, test, and deployment automation
- **Contracts** - Deployable unit specifications

We needed to decide on a repository structure that would:

1. Enable coordinated development across components
2. Simplify dependency management between related modules
3. Support atomic commits across multiple components
4. Facilitate code sharing and refactoring
5. Provide clear module boundaries while maintaining cohesion
6. Support independent versioning of modules

**Problem Statement**: How should we organize the codebase to balance maintainability, development velocity, and deployment flexibility?

---

## Decision

We will use a **mono-repository layout** of type **single-repository** where all components live in one repository with clear module boundaries.

**Structure**:

```text
cli/
├── src/                          # Source code for all modules
│   ├── mcp/                      # MCP servers module
│   │   ├── vscode/               # VSCode action server
│   │   ├── pwsh/                 # PowerShell server
│   │   ├── docs/                 # Documentation server
│   │   └── github/               # GitHub API server
│   └── [other source modules]
├── .vscode/extensions/           # VSCode extension module
│   └── claude-mcp-vscode/
├── automation/                   # Automation scripts module
│   └── sh/
├── docs/                         # Documentation module
│   ├── tutorials/
│   ├── how-to-guides/
│   ├── explanation/
│   └── reference/
├── contracts/                    # Contract definitions module
│   └── deployable-units/
└── requirements/                 # Feature specifications module
    └── [module]/[feature]/
```

**Module Detection**: Modules are identified by:

- Presence of `go.mod` (Go modules)
- Presence of `package.json` (Node.js modules)
- Presence of `pyproject.toml` or `setup.py` (Python modules)
- Conventional directories (docs/, automation/, contracts/)

**Versioning**: Each module is versioned independently using semantic versioning, tracked in commit messages with module prefixes.

---

## Consequences

### Positive

**1. Coordinated Development**:

- Atomic commits across multiple components
- Refactoring across modules in single PR
- Consistent versioning and release coordination

**2. Simplified Dependency Management**:

- No need to publish/consume internal packages
- Direct imports between modules
- Single dependency update workflow

**3. Code Sharing**:

- Easy to share utilities and common code
- Consistent patterns across modules
- Simplified cross-module refactoring

**4. Unified Tooling**:

- Single CI/CD pipeline for all modules
- Consistent build and test commands
- Shared automation scripts

**5. Documentation Cohesion**:

- Single documentation site covering all components
- Cross-references between module docs
- Easier to maintain consistency

**6. Developer Experience**:

- Single clone operation
- All code searchable in one place
- Simplified onboarding

### Negative

**1. Repository Size**:

- Larger initial clone
- More files to index in IDE
- Longer CI runs if not optimized

**2. Build Complexity**:

- Need smart build system to detect changed modules
- Must avoid rebuilding unchanged modules
- Requires module detection logic

**3. Access Control**:

- Cannot restrict access to individual modules via repository permissions
- All contributors see all code

**4. Release Coordination**:

- Must track which modules changed in each release
- Need clear module versioning strategy
- More complex release notes

**5. Merge Conflicts**:

- Higher potential for conflicts with multiple teams
- Need good branching strategy
- Requires coordination on shared files

---

## Alternatives Considered

### Alternative 1: Multi-Repository (Poly-Repo)

**Description**: Separate repository for each major component (CLI, VSCode extension, MCP servers, docs).

**Pros**:

- Clear ownership boundaries
- Independent release cycles
- Smaller repositories
- Granular access control

**Cons**:

- Complex dependency management between repos
- Difficult to make atomic cross-component changes
- Duplicated CI/CD configuration
- Harder to maintain consistency
- Version coordination complexity

**Why Not Chosen**: The tight coupling between components (e.g., VSCode extension depends on MCP servers, CLI uses same patterns) makes cross-repo coordination too costly.

### Alternative 2: Mono-Repository with Git Submodules

**Description**: Main repository with submodules for each component.

**Pros**:

- Independent repositories for each module
- Some benefits of mono-repo structure
- Granular access control possible

**Cons**:

- Complex submodule management
- Easy to get submodules out of sync
- Difficult atomic commits across submodules
- Poor developer experience
- Additional learning curve

**Why Not Chosen**: Submodules add significant complexity without providing enough benefits over a true mono-repository.

### Alternative 3: Mono-Repository with Workspaces Only

**Description**: Use npm/yarn workspaces or Go workspaces without additional module detection.

**Pros**:

- Native package manager support
- Simple dependency resolution
- Good tooling support

**Cons**:

- Limited to one language ecosystem
- Doesn't handle mixed-language mono-repos well
- No module versioning strategy
- No build optimization for unchanged modules

**Why Not Chosen**: Our codebase is multi-language (Go, TypeScript, Python, Bash) and needs a solution that works across all languages.

---

## Implementation Details

**Module Detection Logic**:

- Scan for language-specific markers (go.mod, package.json, pyproject.toml)
- Identify conventional directories (docs/, automation/, contracts/)
- Track module boundaries for change detection

**Commit Message Convention**:

```text
# Single module
module: type: description

# Multiple modules (multi-module commit)
multi-module: type: description
```

**Module Versioning**:

- Semantic versioning per module
- Version tracked in commit messages
- Module version prefix in git tags

**Build Optimization**:

- Detect changed modules via git diff
- Only build/test affected modules
- Cache unchanged module artifacts

---

## References

- [Mono-Repository Explanation](../../explanation/continuous-delivery/index.md)
- [Commit Message Conventions](../../reference/testing/specifications/index.md)

---

## Related Decisions

- [DR-002: Versioning Schemes and Trunk-Based Development](dr00002.md)
