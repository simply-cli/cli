# DR-002: Use Semantic Versioning with Trunk-Based Development

## Status

- [x] Accepted
- [ ] Proposed
- [ ] Rejected
- [ ] Deprecated
- [ ] Superseded

**Date**: 2025-11-03

---

## Context

Operating a mono-repository with multiple independently versioned modules requires:

1. **Clear versioning strategy** - How to version each module independently
2. **Branching strategy** - How to coordinate development across modules
3. **Release process** - How to release modules with different cadences
4. **Traceability** - How to track which version of each module is deployed
5. **Backward compatibility** - How to communicate breaking changes

The platform has multiple stakeholders:

- **Developers** - Need fast iteration and clear version semantics
- **CI/CD** - Needs automated version detection and tagging
- **Users** - Need stability and clear upgrade paths
- **Auditors** - Need complete traceability from requirements to deployment

**Problem Statement**: How should we version modules and manage branches to support rapid development while maintaining stability and traceability?

---

## Decision

We will use **Semantic Versioning (SemVer)** for all modules combined with **Trunk-Based Development** as our branching strategy.

### Versioning Scheme

**Semantic Versioning (MAJOR.MINOR.PATCH)**:

```text
MAJOR version: Breaking changes (incompatible API changes)
MINOR version: New features (backward-compatible)
PATCH version: Bug fixes (backward-compatible)
```

**Examples**:

- `1.0.0` → `1.0.1` - Bug fix
- `1.0.1` → `1.1.0` - New feature
- `1.1.0` → `2.0.0` - Breaking change

### Module Version Tracking

**In Commit Messages**:

```text
# Single module commit
<module>: <type>: <description>

Example:
vscode-ext: feat: add git push action

# Multi-module commit
multi-module: <type>: <description>

Example:
multi-module: feat: establish foundational mono-repository infrastructure
```

**In Git Tags**:

```text
# Module-specific version
<module>-v<version>

Examples:
vscode-ext-v1.2.0
cli-v2.0.1
mcp-vscode-v1.1.5
```

**In Release Notes**:

- Generated from commit messages
- Grouped by module
- Includes all changes since last module version

### Trunk-Based Development

**Branch Strategy**:

```text
main (trunk)
  ↓
  ├── feature branches (short-lived, < 2 days)
  ├── bugfix branches (short-lived, < 1 day)
  └── release tags (on main)
```

**Rules**:

1. **main is always releasable** - All commits must pass tests
2. **Short-lived branches** - Feature branches merge within 1-2 days
3. **No long-lived feature branches** - Use feature flags instead
4. **Direct commits to main allowed** - For small changes with tests
5. **Tags mark releases** - Version tags created on main branch

### Version Increment Rules

**Automatic Version Detection**:

- Analyze commit messages since last module tag
- Determine version bump based on commit types:
  - `feat: ...` → MINOR bump
  - `fix: ...` → PATCH bump
  - `feat!: ...` or `BREAKING CHANGE:` → MAJOR bump

**Manual Override**:

- Explicit version can be specified in commit message
- Used for coordinated major releases

---

## Consequences

### Positive

**1. Clear Version Semantics**:

- Users understand impact of upgrades (MAJOR = breaking, MINOR = safe)
- Semantic versioning is industry standard
- Automated dependency management possible

**2. Fast Integration**:

- Changes integrate to main quickly
- Reduced merge conflicts
- Faster feedback loops

**3. Simplified Branching**:

- No complex git-flow branches
- Easy to understand model
- Less overhead

**4. Continuous Deployment Ready**:

- Main is always deployable
- Can release any module at any time
- Automated release process

**5. Module Independence**:

- Each module versioned separately
- Different release cadences per module
- No forced coordination

**6. Traceability**:

- Git tags provide clear version markers
- Commit messages link to version increments
- Full audit trail from code to release

### Negative

**1. Requires Discipline**:

- Developers must keep changes small
- Tests must be comprehensive
- Main must always be stable

**2. Feature Flags Needed**:

- Incomplete features require flags
- Additional code complexity
- Need flag management strategy

**3. Version Coordination Complexity**:

- Must track multiple module versions
- Release notes must be per-module
- Need tooling for multi-module releases

**4. Breaking Changes Visibility**:

- MAJOR bumps may not be obvious across modules
- Dependency compatibility must be tracked
- Need clear upgrade documentation

**5. Commit Message Discipline**:

- Must follow conventions strictly
- Wrong commit type = wrong version bump
- Requires training and enforcement

---

## Alternatives Considered

### Alternative 1: Git Flow with Unified Versioning

**Description**: Use git-flow (develop, release, hotfix branches) with single version for entire repository.

**Pros**:

- Well-established process
- Clear separation of stable/unstable code
- Simple version tracking (one version)

**Cons**:

- Slower integration (changes sit in develop)
- Complex branching (5+ branch types)
- Merge hell with long-lived branches
- Forces all modules to same version
- Doesn't fit mono-repo with independent modules

**Why Not Chosen**: Too slow for our development velocity, and unified versioning doesn't fit our module-independent release needs.

### Alternative 2: Calendar Versioning (CalVer)

**Description**: Version based on date (e.g., 2025.11.03 or 25.11.3).

**Pros**:

- Clear when version was released
- No debate about MAJOR vs MINOR
- Simple to generate automatically

**Cons**:

- Doesn't communicate compatibility
- Can't determine breaking changes from version
- Less industry adoption
- Doesn't work well with semantic package managers

**Why Not Chosen**: Lack of semantic meaning makes it harder for users to assess upgrade safety.

### Alternative 3: GitHub Flow with Manual Versioning

**Description**: Simple main + feature branches with manual version bumps in package files.

**Pros**:

- Simpler than git-flow
- Full control over versions
- No commit message conventions required

**Cons**:

- Manual version updates error-prone
- Easy to forget version bumps
- No automated versioning possible
- Inconsistent across modules
- More PR noise (version bump commits)

**Why Not Chosen**: Manual versioning doesn't scale with multiple modules and frequent releases.

### Alternative 4: Commitizen with Conventional Commits

**Description**: Same as our decision, but with Commitizen tooling enforcement.

**Pros**:

- Enforced commit conventions
- Interactive commit message builder
- Automatic changelog generation
- Standard tooling

**Cons**:

- Additional tooling dependency
- Learning curve for contributors
- May be too restrictive

**Why Not Chosen**: We may adopt this later, but want to start with conventions before adding tooling requirements.

---

## Implementation Details

### Commit Message Format

**Structure**:

```text
<module>: <type>: <description>

[optional body]

[optional footer]
```

**Types**:

- `feat` - New feature (MINOR bump)
- `fix` - Bug fix (PATCH bump)
- `docs` - Documentation only (PATCH bump)
- `refactor` - Code refactoring (PATCH bump)
- `test` - Test changes (PATCH bump)
- `chore` - Build/tooling changes (PATCH bump)

**Breaking Changes**:

```text
<module>: feat!: <description>

BREAKING CHANGE: <description of breaking change>
```

**Examples**:

```text
vscode-ext: feat: add commit message generation

cli: fix: correct module detection for nested go.mod files

multi-module: feat: establish foundational mono-repository infrastructure

mcp-vscode: feat!: change JSON-RPC protocol version

BREAKING CHANGE: Now requires protocol version 2024-11-05
```

### Version Detection Algorithm

```text
1. Find last git tag for module (e.g., vscode-ext-v1.2.0)
2. Get all commits since that tag for the module
3. Analyze commit messages:
   - Any with "!" or "BREAKING CHANGE" → MAJOR bump
   - Any with "feat:" → MINOR bump (if no MAJOR)
   - Only "fix:", "docs:", etc. → PATCH bump
4. Calculate new version
5. Create git tag: <module>-v<new-version>
```

### Release Process

**Automated**:

```bash
# CI/CD detects changed modules
# For each changed module:
1. Run tests
2. Detect version bump from commits
3. Update package files (package.json, go.mod)
4. Create git tag
5. Generate release notes from commits
6. Create GitHub release
7. Publish artifacts
```

**Manual Override**:

```bash
# For coordinated releases
git tag -a multi-module-v1.0.0 -m "Initial release"
git push --tags
```

### Feature Flags

**For incomplete features**:

```typescript
if (featureFlags.newGitPushAction) {
    // New feature code
} else {
    // Existing code
}
```

**Configuration**:

- Environment variables
- Config files
- Runtime toggles

---

## References

- [Mono-Repository Explanation](../../explanation/continuous-delivery/index.md)
- [Commit Message Examples](../../explanation/continuous-delivery/index.md#commit-message-format)

---

## Related Decisions

- [DR-001: Use Mono-Repository Layout](dr00001.md) - Establishes the need for per-module versioning
