# DR-003: Use Three-Layer Testing Approach (ATDD/BDD/TDD)

## Status

- [x] Accepted
- [ ] Proposed
- [ ] Rejected
- [ ] Deprecated
- [ ] Superseded

**Date**: 2025-11-03

---

## Context

The Simply CLI platform requires a comprehensive testing strategy that:

1. **Captures business requirements** - Tests must validate business value
2. **Enables collaboration** - Business stakeholders, QA, and developers need shared understanding
3. **Supports traceability** - Requirements must link to tests and implementation
4. **Provides fast feedback** - Different test granularities for different purposes
5. **Supports audit/compliance** - Clear verification of requirements
6. **Works across languages** - Platform uses Go, TypeScript, Python, Bash

Traditional single-layer testing (unit tests only) doesn't adequately:

- Document business requirements in testable form
- Enable non-technical stakeholders to review acceptance criteria
- Provide clear traceability from requirements to code
- Support regulatory/audit documentation needs

**Problem Statement**: How should we structure our testing to bridge business requirements and technical implementation while maintaining traceability?

---

## Decision

We will use a **three-layer testing approach** with separate tools and files for each layer:

### Layer 1: ATDD (Acceptance Test-Driven Development)

**Tool**: Gauge
**File**: `acceptance.spec` (Markdown format)
**Purpose**: Business requirements and acceptance criteria

**Characteristics**:

- Written in natural language
- Readable by all stakeholders
- Documents user stories and acceptance criteria
- Captures Example Mapping workshop results
- Defines what "done" means

### Layer 2: BDD (Behavior-Driven Development)

**Tool**: Godog (Go) / Cucumber (other languages)
**File**: `behavior.feature` (Gherkin format)
**Purpose**: Executable scenarios in Given/When/Then format

**Characteristics**:

- Written in Gherkin syntax
- Converts acceptance criteria to testable scenarios
- Bridges business language and technical implementation
- Automated through step definitions
- Tagged by verification type (@IV/@PV) and acceptance criteria (@ac1, @ac2)

### Layer 3: TDD (Test-Driven Development)

**Tool**: Go test framework
**File**: `*_test.go`
**Purpose**: Drive implementation through unit tests

**Characteristics**:

- Written in programming language
- Tests individual components and functions
- Fast, isolated, repeatable
- Written before implementation code

### File Organization

```text
requirements/<module>/<feature>/
├── acceptance.spec              # Gauge (ATDD)
├── behavior.feature             # Godog (BDD)
├── acceptance_test.go           # Gauge step implementations
├── step_definitions_test.go     # Godog step definitions
└── issues.md                    # Optional: open questions

src/<module>/
└── *_test.go                    # Unit tests (TDD)
```

---

## Consequences

### Positive

**1. Clear Separation of Concerns**:

- Business requirements separate from implementation details
- Each layer has specific audience and purpose
- No confusion about test granularity

**2. Stakeholder Communication**:

- acceptance.spec readable by non-technical stakeholders
- Shared vocabulary between business and technical teams
- Clear acceptance criteria review process

**3. Complete Traceability**:

- Feature ID links all layers
- Acceptance criteria link to BDD scenarios (@ac1, @ac2 tags)
- BDD scenarios link to unit tests
- Full audit trail from requirement to code

**4. Multiple Test Granularities**:

- ATDD: High-level business validation
- BDD: Integration and behavior verification
- TDD: Fast unit-level feedback

**5. Regulatory Compliance**:

- Clear verification types (IV/OV/PV) in BDD layer
- Traceability for audit requirements
- Test results grouped by verification type in reports

**6. Flexibility Across Languages**:

- Each language can use appropriate TDD tools
- BDD layer (Godog/Cucumber) works across languages
- ATDD layer (Gauge) language-agnostic

### Negative

**1. Learning Curve**:

- Team must learn three different tools
- Different syntax for each layer (Markdown, Gherkin, code)
- Requires understanding of ATDD/BDD/TDD concepts

**2. Initial Setup Overhead**:

- Must create three files per feature
- Step implementations needed for both Gauge and Godog
- More files to maintain

**3. Potential Duplication**:

- Similar scenarios might appear in multiple layers
- Must maintain consistency across layers
- Risk of tests diverging over time

**4. Tool Dependencies**:

- Requires Gauge, Godog/Cucumber, and language-specific test frameworks
- More tools to install and maintain
- Version compatibility concerns

**5. Execution Time**:

- Running all three layers takes longer than single layer
- Need CI optimization to run efficiently
- May need parallel execution strategy

---

## Alternatives Considered

### Alternative 1: BDD Only (Cucumber/Godog)

**Description**: Use only BDD with Gherkin scenarios, skip separate ATDD layer.

**Pros**:

- Fewer tools to learn
- Single source of scenarios
- Good collaboration potential

**Cons**:

- Gherkin can become too technical for stakeholders
- No separate business-readable requirements document
- Scenarios mix high-level and low-level concerns
- Harder to review for non-technical stakeholders

**Why Not Chosen**: Gherkin scenarios tend to become technical over time, losing business readability. Separate ATDD layer maintains business focus.

### Alternative 2: Traditional TDD with Documentation

**Description**: Write comprehensive unit tests and maintain separate requirements docs.

**Pros**:

- Familiar to developers
- Fast test execution
- Simple tooling

**Cons**:

- Documentation diverges from tests
- No executable requirements
- Poor traceability
- No collaboration on acceptance criteria
- Harder to review business value

**Why Not Chosen**: Doesn't support collaboration with non-technical stakeholders or provide executable requirements.

### Alternative 3: Single Tool (e.g., Gauge for Everything)

**Description**: Use Gauge for all test layers with different specification files.

**Pros**:

- Single tool to learn
- Consistent syntax
- Simpler setup

**Cons**:

- Forces all tests into same format
- Unit tests in Markdown less efficient than native test frameworks
- Slower unit test execution
- Less flexibility for language-specific patterns

**Why Not Chosen**: Unit tests work best in native test frameworks with fast execution and IDE integration.

### Alternative 4: Specification by Example Only

**Description**: Use Example Mapping workshops but skip tool-based executable specifications.

**Pros**:

- Lightweight process
- No tool dependencies
- Flexible format

**Cons**:

- Examples become stale
- No automated verification
- Poor traceability to implementation
- Manual checking of acceptance criteria

**Why Not Chosen**: Need automated verification and traceability for audit/compliance requirements.

---

## Implementation Details

### Feature ID Linkage

All three layers link via Feature ID:

```text
acceptance.spec:
  > **Feature ID**: cli_init_project

behavior.feature:
  # Feature ID: cli_init_project

*_test.go:
  // Feature: cli_init_project
```

### Acceptance Criteria Linking

```text
acceptance.spec:
  ### AC1: System initializes project structure
  **Validated by**: behavior.feature -> @ac1 scenarios

behavior.feature:
  @success @ac1
  Scenario: Initialize project with default structure
```

### Test Execution

```bash
# Run all three layers
gauge run requirements/              # ATDD
godog requirements/**/behavior.feature  # BDD
go test ./...                        # TDD

# Run by verification type (BDD)
godog --tags="@IV" requirements/**/behavior.feature
godog --tags="@PV" requirements/**/behavior.feature
```

### Example Mapping to Specifications

**Workshop Output** → **Specifications**:

- Yellow Card (User Story) → acceptance.spec header
- Blue Cards (Rules) → Acceptance Criteria sections
- Green Cards (Examples) → BDD Scenarios
- Red Cards (Questions) → issues.md

---

## References

- [ATDD Guide](../../reference/testing/specifications/atdd.md)
- [BDD Guide](../../reference/testing/specifications/bdd.md)
- [TDD Guide](../../reference/testing/specifications/tdd.md)
- [Testing Specifications Overview](../../reference/testing/specifications/index.md)
- [Requirements Templates](../../templates/requirements/)

---

## Related Decisions

- [DR-007: Verification Tags for Regulatory Compliance](dr007.md) - Uses BDD layer for IV/OV/PV tagging
- [DR-008: Feature Specifications Structure](dr008.md) - Directory organization for specs
