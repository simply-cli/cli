# DR-002: Use Semantic Versioning with Trunk-Based Development

## Status

- [x] Accepted
- [ ] Proposed
- [ ] Rejected
- [ ] Deprecated
- [ ] Superseded

**Date**: 2025-11-03

---

## Context

Mono-repository with multiple independently versioned modules requires:

1. Clear versioning strategy for independent modules
2. Branching strategy for coordinated development
3. Release process for different cadences
4. Traceability from requirements to deployment
5. Backward compatibility communication

**Problem**: How to version modules and manage branches to support rapid development while maintaining stability and traceability?

---

## Decision

Use **Semantic Versioning (SemVer)** for all modules with **Trunk-Based Development** branching strategy.

### Semantic Versioning

Format: `MAJOR.MINOR.PATCH`

- **MAJOR**: Breaking changes
- **MINOR**: New features (backward-compatible)
- **PATCH**: Bug fixes (backward-compatible)

### Commit Message Format

```text
# Single module
<module>: <type>: <description>

Examples:
vscode-ext: feat: add git push action
cli: fix: correct module detection

# Multi-module
multi-module: <type>: <description>
```

### Git Tags

```text
# Module-specific
<module>-v<version>

Examples:
vscode-ext-v1.2.0
cli-v2.0.1
```

### Trunk-Based Development

```text
main (trunk) - always releasable
  ↓
  ├── feature branches (< 2 days)
  ├── bugfix branches (< 1 day)
  └── release tags
```

**Rules**:

1. main always releasable (all commits pass tests)
2. Short-lived branches (1-2 days max)
3. Use feature flags for incomplete work
4. Tags mark releases on main

### Version Increment

Determined by commit types:

- `feat:` → MINOR bump
- `fix:` → PATCH bump
- `feat!:` or `BREAKING CHANGE:` → MAJOR bump

---

## Consequences

### Positive

- **Clear semantics**: Users understand upgrade impact (MAJOR = breaking, MINOR = safe)
- **Fast integration**: Changes merge quickly, reduced conflicts, faster feedback
- **Simplified branching**: No complex git-flow, easy model, less overhead
- **Continuous deployment**: Main always deployable, release any module anytime
- **Module independence**: Separate versioning, different release cadences
- **Traceability**: Git tags + commit messages provide full audit trail

### Negative

- **Discipline required**: Small changes, comprehensive tests, stable main
- **Feature flags needed**: Incomplete features need flags, additional complexity
- **Version coordination**: Must track multiple module versions, need tooling
- **Commit conventions**: Must follow strictly, wrong type = wrong version bump

---

## Alternatives Considered

### 1. Git Flow with Unified Versioning

Use git-flow (develop, release, hotfix branches) with single repository version.

**Why Not Chosen**: Too slow for development velocity. Unified versioning doesn't fit module-independent releases.

### 2. Calendar Versioning (CalVer)

Version based on date (e.g., 2025.11.03).

**Why Not Chosen**: Doesn't communicate compatibility or breaking changes. Users can't assess upgrade safety.

### 3. Manual Versioning

Manual version bumps in package files.

**Why Not Chosen**: Error-prone, easy to forget, doesn't scale with multiple modules and frequent releases.

---

## Implementation

### Commit Types

- `feat` - New feature (MINOR)
- `fix` - Bug fix (PATCH)
- `docs` - Documentation (PATCH)
- `refactor` - Code refactoring (PATCH)
- `test` - Test changes (PATCH)
- `chore` - Build/tooling (PATCH)

### Breaking Changes

```text
<module>: feat!: <description>

BREAKING CHANGE: <description>
```

### Version Detection

1. Find last git tag for module
2. Get commits since tag
3. Analyze: BREAKING CHANGE → MAJOR, feat → MINOR, others → PATCH
4. Create tag: `<module>-v<new-version>`

### Release Process

```bash
# Automated CI/CD
1. Run tests
2. Detect version bump from commits
3. Update package files
4. Create git tag
5. Generate release notes
6. Publish artifacts
```

---

## Related Decisions

- [DR-001: Mono-Repository Layout](dr001.md)
